import json
import logging

import bcrypt

from sqlalchemy import Column, Integer, String, TIMESTAMP, func, Enum, ForeignKey, Boolean
from sqlalchemy.orm import composite

from app.src.entities.database import Base
from app.src.entities.db_references import RefDBName, RefInfo

logger = logging.getLogger(__name__)

created_date_comment = "Date of the creation of the field"
updated_date_comment = "Last updated date"
datetime_format = '%Y-%m-%dT%H:%M:%S:%f'


class User(Base):
    __tablename__ = "users"
    __table_args__ = {
        'comment': 'Table containing user information.'
    }
    id = Column(Integer, primary_key=True)
    username = Column(String, nullable=False, unique=True, comment="email or service name")
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False,
                        comment=created_date_comment)
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False,
                        comment=updated_date_comment)

    hash_password = Column(String, nullable=False)
    role = Column(String, nullable=False)

    @staticmethod
    def set_password(password):
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        return hashed_password.decode('utf-8')

    def check_password(self, password):
        return bcrypt.checkpw(password.encode('utf-8'), self.hash_password.encode('utf-8'))

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "role": self.role,
            "created_at": self.created_at.strftime(datetime_format),
            "updated_at": self.updated_at.strftime(datetime_format)
        }

    def to_json(self):
        return json.dumps(self.to_dict())


class Request(Base):
    __tablename__ = "requests"
    __table_args__ = {
        'comment': 'Table containing all requests sent to llm.'
    }
    id = Column(Integer, primary_key=True, nullable=False, comment="ID generated when creating request")
    user_id = Column(Integer, ForeignKey('users.id'), nullable=True)
    ref = composite(RefInfo,
                    Column('ref_id', Integer, nullable=True, comment="ID for Reference table"),
                    Column('ref_table', Enum(RefDBName), nullable=True, comment="Reference table name")
                    )
    model = Column(String, nullable=False, comment="Name of the LLM model used")
    prompt = Column(String, nullable=True, comment="Prompt used by the llm")
    input = Column(String, nullable=False, comment="List of inputs used by the LLM")
    output = Column(String, nullable=True, comment="Answer generated by the LLM")
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False,
                        comment=created_date_comment)
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False,
                        comment=updated_date_comment)

    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "ref": self.ref.as_dict(),
            "model": self.model,
            "prompt": self.prompt if self.prompt else None,
            "input": self.input,
            "output": self.output,
            "created_at": self.created_at.strftime(datetime_format),
            "updated_at": self.updated_at.strftime(datetime_format)
        }

    def to_json(self):
        return json.dumps(self.to_dict())


class Mission(Base):
    __tablename__ = "missions"
    __table_args__ = {
        'comment': 'Table containing all missions sent to llm.'
    }
    id = Column(Integer, primary_key=True, nullable=False, comment="ID generated when creating mission")
    client_id = Column(Integer, ForeignKey('clients.id'), nullable=True, comment="ID from clients table")
    name = Column(String, nullable=False, comment="Name of the mission")
    description = Column(String, nullable=False, comment="Original description of the mission")
    content = Column(String, nullable=False, comment="Mission description generated by llm")
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False,
                        comment=created_date_comment)
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now(),
                        comment=updated_date_comment)

    def to_dict(self):
        return {
            "id": self.id,
            "client_id": self.client_id,
            "name": self.name,
            'content': self.content,
            'created_at': self.created_at.strftime(datetime_format),
            'updated_at': self.updated_at.strftime(datetime_format)
        }

    def to_json(self):
        return json.dumps(self.to_dict())

    @staticmethod
    def get_ref_db_name():
        return RefDBName.mission


class Client(Base):
    __tablename__ = "clients"
    __table_args__ = {
        'comment': 'Table containing client information and activities.'
    }
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False, unique=True, comment="client name")
    sector = Column(String, nullable=True, comment="client sector")
    content = Column(String, nullable=False, comment="client activities")
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False,
                        comment=created_date_comment)
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now(),
                        comment=updated_date_comment)

    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "sector": self.sector if self.sector is not None else None,
            "content": self.content,
            'created_at': self.created_at.strftime(datetime_format),
            'updated_at': self.updated_at.strftime(datetime_format)
        }

    def to_json(self):
        return json.dumps(self.to_dict())

    @staticmethod
    def get_ref_db_name():
        return RefDBName.client


class Logs(Base):
    __tablename__ = "logs"
    __table_args__ = {
        'comment': 'Table containing logging information and errors.'
    }
    id = Column(Integer, primary_key=True)
    request_id = Column(Integer, ForeignKey('requests.id'), nullable=True, comment="ID from requests table")
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, comment="ID from users table")
    ref_id = Column(Integer, nullable=True, comment="ID from mission or client table")
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), nullable=False,
                        comment=created_date_comment)
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now(),
                        comment=updated_date_comment)
    ended_at = Column(TIMESTAMP(timezone=True), nullable=True,
                      comment='Date of the end of the request')
    get_answer_azure = Column(String, nullable=True, comment="The step where we get response from AI generative model: "
                                                             "None if ok or the error in the field if not")
    save_request = Column(String, nullable=True, comment="The step where we save the request. None if ok "
                                                         "or the error in the field if not")
    save_results = Column(String, nullable=True, comment="The step where we save the results received from the model: "
                                                         "None if ok or the error in the field if not")
    get_content = Column(String, nullable=True, comment="The step where we get the results from database in case "
                                                        "of client/mission already generated previously. "
                                                        "None if ok or the error in the field if not")
    failure = Column(Boolean, nullable=False, comment="is the process failed in any of the process steps")
    ref_table = Column(String, nullable=False, comment="Log type : mission / client")

    def to_dict(self):
        return {
            'request_id': self.request_id,
            'user_id': self.user_id,
            'ref_id': self.ref_id,
            'ref_table': self.ref_table,
            'get_answer_azure': self.get_answer_azure,
            'save_request': self.save_request,
            'save_results': self.save_results,
            'get_content': self.get_content,
            'failure': self.failure,
            'ended_at': self.ended_at,
            'created_at': self.created_at,
            'updated_at': self.updated_at
        }

    def to_json(self):
        return json.dumps(self.to_dict())

    @staticmethod
    def get_ref_db_name():
        return RefDBName.client
